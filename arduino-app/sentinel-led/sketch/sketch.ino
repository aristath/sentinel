/**
 * sketch.ino - Scrolling text display for Arduino UNO Q
 *
 * Displays trade instructions as scrolling text on LED matrix.
 * MCU fetches next trade from Python when done scrolling (pull-based).
 */

#include <Arduino_RouterBridge.h>
#include <Arduino_LED_Matrix.h>

Arduino_LED_Matrix matrix;

// 5x7 font for basic characters (space, $, %, (, ), 0-9, A-Z, .)
const uint8_t FONT_5X7[][5] = {
  {0x00, 0x00, 0x00, 0x00, 0x00}, // 32 space
  {0x00, 0x00, 0x00, 0x00, 0x00}, // 33 !
  {0x00, 0x00, 0x00, 0x00, 0x00}, // 34 "
  {0x00, 0x00, 0x00, 0x00, 0x00}, // 35 #
  {0x24, 0x2A, 0x7F, 0x2A, 0x12}, // 36 $
  {0x23, 0x13, 0x08, 0x64, 0x62}, // 37 %
  {0x00, 0x00, 0x00, 0x00, 0x00}, // 38 &
  {0x00, 0x00, 0x00, 0x00, 0x00}, // 39 '
  {0x00, 0x1C, 0x22, 0x41, 0x00}, // 40 (
  {0x00, 0x41, 0x22, 0x1C, 0x00}, // 41 )
  {0x00, 0x00, 0x00, 0x00, 0x00}, // 42 *
  {0x00, 0x00, 0x00, 0x00, 0x00}, // 43 +
  {0x00, 0x50, 0x30, 0x00, 0x00}, // 44 ,
  {0x08, 0x08, 0x08, 0x08, 0x08}, // 45 -
  {0x00, 0x60, 0x60, 0x00, 0x00}, // 46 .
  {0x00, 0x00, 0x00, 0x00, 0x00}, // 47 /
  {0x3E, 0x51, 0x49, 0x45, 0x3E}, // 48 0
  {0x00, 0x42, 0x7F, 0x40, 0x00}, // 49 1
  {0x42, 0x61, 0x51, 0x49, 0x46}, // 50 2
  {0x21, 0x41, 0x45, 0x4B, 0x31}, // 51 3
  {0x18, 0x14, 0x12, 0x7F, 0x10}, // 52 4
  {0x27, 0x45, 0x45, 0x45, 0x39}, // 53 5
  {0x3C, 0x4A, 0x49, 0x49, 0x30}, // 54 6
  {0x01, 0x71, 0x09, 0x05, 0x03}, // 55 7
  {0x36, 0x49, 0x49, 0x49, 0x36}, // 56 8
  {0x06, 0x49, 0x49, 0x29, 0x1E}, // 57 9
  {0x00, 0x00, 0x00, 0x00, 0x00}, // 58 :
  {0x00, 0x00, 0x00, 0x00, 0x00}, // 59 ;
  {0x00, 0x00, 0x00, 0x00, 0x00}, // 60 <
  {0x00, 0x00, 0x00, 0x00, 0x00}, // 61 =
  {0x00, 0x00, 0x00, 0x00, 0x00}, // 62 >
  {0x00, 0x00, 0x00, 0x00, 0x00}, // 63 ?
  {0x00, 0x00, 0x00, 0x00, 0x00}, // 64 @
  {0x7E, 0x11, 0x11, 0x11, 0x7E}, // 65 A
  {0x7F, 0x49, 0x49, 0x49, 0x36}, // 66 B
  {0x3E, 0x41, 0x41, 0x41, 0x22}, // 67 C
  {0x7F, 0x41, 0x41, 0x22, 0x1C}, // 68 D
  {0x7F, 0x49, 0x49, 0x49, 0x41}, // 69 E
  {0x7F, 0x09, 0x09, 0x09, 0x01}, // 70 F
  {0x3E, 0x41, 0x49, 0x49, 0x7A}, // 71 G
  {0x7F, 0x08, 0x08, 0x08, 0x7F}, // 72 H
  {0x00, 0x41, 0x7F, 0x41, 0x00}, // 73 I
  {0x20, 0x40, 0x41, 0x3F, 0x01}, // 74 J
  {0x7F, 0x08, 0x14, 0x22, 0x41}, // 75 K
  {0x7F, 0x40, 0x40, 0x40, 0x40}, // 76 L
  {0x7F, 0x02, 0x0C, 0x02, 0x7F}, // 77 M
  {0x7F, 0x04, 0x08, 0x10, 0x7F}, // 78 N
  {0x3E, 0x41, 0x41, 0x41, 0x3E}, // 79 O
  {0x7F, 0x09, 0x09, 0x09, 0x06}, // 80 P
  {0x3E, 0x41, 0x51, 0x21, 0x5E}, // 81 Q
  {0x7F, 0x09, 0x19, 0x29, 0x46}, // 82 R
  {0x46, 0x49, 0x49, 0x49, 0x31}, // 83 S
  {0x01, 0x01, 0x7F, 0x01, 0x01}, // 84 T
  {0x3F, 0x40, 0x40, 0x40, 0x3F}, // 85 U
  {0x1F, 0x20, 0x40, 0x20, 0x1F}, // 86 V
  {0x3F, 0x40, 0x38, 0x40, 0x3F}, // 87 W
  {0x63, 0x14, 0x08, 0x14, 0x63}, // 88 X
  {0x07, 0x08, 0x70, 0x08, 0x07}, // 89 Y
  {0x61, 0x51, 0x49, 0x45, 0x43}, // 90 Z
};

// Matrix dimensions
const int WIDTH = 13;
const int HEIGHT = 8;
const int CHAR_WIDTH = 6;

uint8_t frameBuffer[HEIGHT][WIDTH];

int getCharIndex(char c) {
  if (c >= 32 && c <= 90) return c - 32;
  if (c >= 'a' && c <= 'z') return c - 'a' + 33;
  return 0;
}

void drawChar(int x, char c) {
  int idx = getCharIndex(c);
  if (idx < 0 || idx >= 59) idx = 0;

  for (int col = 0; col < 5; col++) {
    int screenX = x + col;
    if (screenX >= 0 && screenX < WIDTH) {
      uint8_t colData = FONT_5X7[idx][col];
      for (int row = 0; row < 7; row++) {
        if (colData & (1 << row)) {
          frameBuffer[row][screenX] = 1;
        }
      }
    }
  }
}

void renderText(const String& text, int offset) {
  memset(frameBuffer, 0, sizeof(frameBuffer));

  int x = -offset;
  for (unsigned int i = 0; i < text.length(); i++) {
    if (x > WIDTH) break;
    if (x + CHAR_WIDTH > 0) {
      drawChar(x, text.charAt(i));
    }
    x += CHAR_WIDTH;
  }

  uint32_t frame[4] = {0, 0, 0, 0};
  for (int row = 0; row < HEIGHT; row++) {
    for (int col = 0; col < WIDTH; col++) {
      if (frameBuffer[row][col]) {
        int bitIndex = row * WIDTH + col;
        int wordIndex = bitIndex / 32;
        int bitPos = 31 - (bitIndex % 32);
        frame[wordIndex] |= (1UL << bitPos);
      }
    }
  }

  matrix.loadFrame(frame);
}

void scrollText(const String& text) {
  String padded = text + "   ";
  int totalWidth = padded.length() * CHAR_WIDTH;

  // Start with text off-screen to the right, scroll left until off-screen
  for (int pos = -WIDTH; pos < totalWidth; pos++) {
    renderText(padded, pos);
    delay(80);
  }

  matrix.clear();
}

String fetchNextTrade() {
  String text;
  Bridge.call("getNextTrade").result(text);
  return text;
}

void setup() {
  matrix.begin();
  matrix.clear();
  Bridge.begin();
}

void loop() {
  String trade = fetchNextTrade();

  if (trade.length() > 0) {
    scrollText(trade);
  }

  delay(500); // Brief pause between trades
}
